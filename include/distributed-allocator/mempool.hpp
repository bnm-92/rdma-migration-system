#ifndef __MEMPOOL_HPP__
#define __MEMPOOL_HPP__

/**
 * This is a Mempool implementation, This is used by c++-container class
 * to allocate and deallocate memory to the container, the mempool is generated by RDMAMemoryManager
 * this class is intended to create a an interface for memory accesses for the data structure that resides in it.
*/

#include <unordered_set>
#include "utils/miscutils.hpp"

class MemoryPool {
public:
    // Constructor.
    MemoryPool(void* pool_addr, size_t pool_size);

    // Disable the copy constructor and copy assignment operators for now.
    // (We'll re-enable operators as necessary.)
    MemoryPool(const MemoryPool&) = delete;
    MemoryPool& operator=(const MemoryPool&) = delete;

    // Allocate size_t bytes from this memory pool.
    // Returns the address you can use.
    void* allocate(size_t) noexcept;

    // Deallocate an address that was allocated from this pool.
    // Note: currently a no-op. You'll probably want to implement your
    // favourite memory allocation algorithm at some point.
    void deallocate(void*, size_t) noexcept;

    friend std::ostream& operator<<(std::ostream&, const MemoryPool&);


// protected:
    /**
     * MemoryPool metadata and state.
     * The reason this may be different from the actual addr and size of the 
     * underlying memory is because we may choose to embed information in the memory address themselves
     * this will not be required if we are using zookeeper
    */
    void* pool_addr;
    size_t pool_size;

    /**
     * The high watermark for allocated memory, this class implements a
     * simple allocation algorithm by simply pushing the boundary forward, on an
     * RDMA pull, we would only need to pull as much as a unused past
    */
    void* unused_past;

    //the actualy add and size of the rdma memory region
    void* addr;
    size_t size;
};

#include "distributed-allocator/mempool.tpp"

#endif // __MEMPOOL_HPP__
